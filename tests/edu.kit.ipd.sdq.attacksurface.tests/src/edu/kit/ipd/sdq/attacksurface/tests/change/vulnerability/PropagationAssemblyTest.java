package edu.kit.ipd.sdq.attacksurface.tests.change.vulnerability;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Arrays;
import java.util.HashSet;
import java.util.Optional;

import org.eclipse.emf.ecore.util.EcoreUtil;
import org.junit.Assert;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.palladiosimulator.pcm.allocation.AllocationContext;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.ConfidentialityImpact;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Privileges;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.PcmIntegrationFactory;
import org.palladiosimulator.pcm.confidentiality.context.system.UsageSpecification;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.StructureFactory;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.core.entity.Entity;
import org.palladiosimulator.pcm.repository.BasicComponent;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF;

import com.google.common.graph.EndpointPair;

import edu.kit.ipd.sdq.attacksurface.graph.AttackPathSurface;
import edu.kit.ipd.sdq.attacksurface.graph.AttackStatusEdge;
import edu.kit.ipd.sdq.attacksurface.graph.AttackStatusEdgeContent;
import edu.kit.ipd.sdq.attacksurface.graph.AttackStatusNodeContent;
import edu.kit.ipd.sdq.attacksurface.graph.CVSurface;
import edu.kit.ipd.sdq.attacksurface.graph.VulnerabilitySurface;
import edu.kit.ipd.sdq.attacksurface.tests.change.AbstractChangeTests;
import edu.kit.ipd.sdq.attacksurface.core.changepropagation.changes.AssemblyContextPropagationVulnerability;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.KAMP4attackModificationmarksFactory;

class PropagationAssemblyTest extends AbstractChangeTests {
    private ResourceContainer getResource(final AssemblyContext infectedAssembly) {
        final var resourceOpt = this.allocation.getAllocationContexts_Allocation().stream()
                .filter(e -> EcoreUtil.equals(e.getAssemblyContext_AllocationContext(), infectedAssembly))
                .map(AllocationContext::getResourceContainer_AllocationContext).findAny();
        if (resourceOpt.isEmpty()) {
            fail("Wrong Test Input");
        }
        return resourceOpt.orElse(null);
    }

    private void runAssemblyResourcePropagation(final CredentialChange change) {
        final var wrapper = getBlackboardWrapper();
        final var assemblyChange = new AssemblyContextPropagationVulnerability(wrapper, change, getAttackGraph());
        assemblyChange.calculateAssemblyContextToLocalResourcePropagation();
        assemblyChange.calculateAssemblyContextToRemoteResourcePropagation();
    }

    private void runAssemblyAssemblyPropagation(final CredentialChange change) {
        generateXML();
        final var wrapper = getBlackboardWrapper();
        final var assemblyChange = new AssemblyContextPropagationVulnerability(wrapper, change, getAttackGraph());
        assemblyChange.calculateAssemblyContextToAssemblyContextPropagation();
    }

    private void runAssemblyLinkingPropagation(final CredentialChange change) {
        final var wrapper = getBlackboardWrapper();
        final var assemblyChange = new AssemblyContextPropagationVulnerability(wrapper, change, getAttackGraph());
        assemblyChange.calculateAssemblyContextToLinkingResourcePropagation();
    }
    
    @Test
    public void dontCompromiseCriticalTest() {
        runAssemblyAssemblyPropagation(getChanges());
        final var criticalEntity = getCriticalEntity();
        Assert.assertTrue(isInGraph(criticalEntity));
        assertCompromisationStatus(false, criticalEntity, null);
        
        final var attackPaths = getAttackGraph().findAllAttackPaths();
        Assert.assertEquals(0, attackPaths.size());
    }
    
    @Test
    public void compromiseCriticalVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var terminal = getFirstEntityByName("Assembly_UserTerminal");
        integrateVulnerability(criticalEntity, vuln);
        
        runAssemblyAssemblyPropagation(getChanges());
        Assert.assertTrue(isInGraph(criticalEntity));
        assertCompromisationStatus(true, criticalEntity, vuln.getId());
        
        final var attackPaths = getAttackGraph().findAllAttackPaths();
        final var attackPathsSet = new HashSet<>(attackPaths);
        final var content = new AttackStatusEdgeContent();
        content.addSet(new HashSet<CVSurface>(Arrays.asList(new VulnerabilitySurface(vuln.getId()))));
        final var expectedSet = new HashSet<>(Arrays.asList(new AttackPathSurface[] {
            new AttackPathSurface(
                    Arrays.asList(toEdge(content, criticalEntity, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(toEdge(content, terminal, criticalEntity)))
        }));
        Assert.assertEquals(2, attackPaths.size());
        attackPaths.forEach(p -> System.out.println(p));
        System.out.println("-----");
        expectedSet.forEach(p -> System.out.println(p));
        Assert.assertEquals(expectedSet, attackPathsSet);
    }
    
    @Test
    public void compromiseCriticalAndTerminalVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var userDb = getFirstEntityByName("Assembly_UserDB");
        final var terminal = getFirstEntityByName("Assembly_UserTerminal");
        integrateVulnerability(criticalEntity, vuln);
        integrateVulnerability(terminal, vuln);
        
        runAssemblyAssemblyPropagation(getChanges());
        Assert.assertTrue(isInGraph(criticalEntity));
        assertCompromisationStatus(true, criticalEntity, vuln.getId());
        
        final var attackPaths = getAttackGraph().findAllAttackPaths();
        final var attackPathsSet = new HashSet<>(attackPaths);
        final var content = new AttackStatusEdgeContent();
        content.addSet(new HashSet<CVSurface>(Arrays.asList(new VulnerabilitySurface(vuln.getId()))));
        final var expectedSet = new HashSet<>(Arrays.asList(new AttackPathSurface[] {
            new AttackPathSurface(
                        Arrays.asList(
                                toEdge(content, userDb, terminal),
                                toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(toEdge(content, criticalEntity, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, terminal, terminal), 
                            toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, criticalEntity, terminal), 
                            toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, criticalEntity, terminal), 
                            toEdge(content, terminal, terminal), 
                            toEdge(content, terminal, criticalEntity)))
        }));
        attackPaths.forEach(p -> System.out.println(p));
        System.out.println("-----");
        expectedSet.forEach(p -> System.out.println(p));
        Assert.assertEquals(6, attackPaths.size());
        Assert.assertEquals(expectedSet, attackPathsSet);
    }
    
    @Test
    public void compromiseCriticalContainerVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var criticalContainingResource = getResource((AssemblyContext)criticalEntity);
        integrateVulnerability(criticalContainingResource, vuln);
        
        runAssemblyResourcePropagation(getChanges());
        assertCompromisationStatus(true, criticalContainingResource, vuln.getId());
    }
    
    @Test
    public void compromiseOtherContainerlVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var resource = this.getConnectedResourceContainers(
                getResource((AssemblyContext)criticalEntity)).get(0);
        integrateVulnerability(resource, vuln);
        
        runAssemblyResourcePropagation(getChanges());
        assertCompromisationStatus(true, resource, vuln.getId());
    }

    private AttackStatusEdge toEdge(AttackStatusEdgeContent content, Entity attacker, Entity attacked) {
        return new AttackStatusEdge(content, 
                EndpointPair.ordered(
                        new AttackStatusNodeContent(attacker), 
                        new AttackStatusNodeContent(attacked)));
    }
}
