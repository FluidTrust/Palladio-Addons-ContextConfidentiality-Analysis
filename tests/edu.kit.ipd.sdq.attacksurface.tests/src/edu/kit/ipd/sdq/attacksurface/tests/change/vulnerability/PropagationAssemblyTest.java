package edu.kit.ipd.sdq.attacksurface.tests.change.vulnerability;

import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;
import static org.junit.Assert.fail;
import static org.junit.jupiter.api.Assertions.assertEquals;

import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;

import org.eclipse.emf.ecore.util.EcoreUtil;
import org.junit.Assert;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.palladiosimulator.pcm.allocation.AllocationContext;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.ConfidentialityImpact;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Privileges;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.PcmIntegrationFactory;
import org.palladiosimulator.pcm.confidentiality.context.system.UsageSpecification;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.StructureFactory;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.core.entity.Entity;
import org.palladiosimulator.pcm.repository.BasicComponent;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;
import org.palladiosimulator.pcm.seff.ResourceDemandingSEFF;

import com.google.common.graph.EndpointPair;

import edu.kit.ipd.sdq.attacksurface.graph.AttackPathSurface;
import edu.kit.ipd.sdq.attacksurface.graph.AttackStatusEdge;
import edu.kit.ipd.sdq.attacksurface.graph.AttackStatusEdgeContent;
import edu.kit.ipd.sdq.attacksurface.graph.AttackStatusNodeContent;
import edu.kit.ipd.sdq.attacksurface.graph.CredentialsVulnearbilitiesSurface;
import edu.kit.ipd.sdq.attacksurface.graph.VulnerabilitySurface;
import edu.kit.ipd.sdq.attacksurface.tests.change.AbstractChangeTests;
import edu.kit.ipd.sdq.attacksurface.core.changepropagation.changes.AssemblyContextPropagationVulnerability;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.KAMP4attackModificationmarksFactory;

class PropagationAssemblyTest extends AbstractChangeTests {

    private void runAssemblyResourcePropagation(final CredentialChange change) {
        final var wrapper = getBlackboardWrapper();
        final var assemblyChange = new AssemblyContextPropagationVulnerability(wrapper, change, getAttackGraph());
        assemblyChange.calculateAssemblyContextToLocalResourcePropagation();
        assemblyChange.calculateAssemblyContextToRemoteResourcePropagation();
    }

    private void runAssemblyAssemblyPropagation(final CredentialChange change) {
        generateXML();
        final var wrapper = getBlackboardWrapper();
        final var assemblyChange = new AssemblyContextPropagationVulnerability(wrapper, change, getAttackGraph());
        assemblyChange.calculateAssemblyContextToAssemblyContextPropagation();
    }

    private void runAssemblyLinkingPropagation(final CredentialChange change) {
        final var wrapper = getBlackboardWrapper();
        final var assemblyChange = new AssemblyContextPropagationVulnerability(wrapper, change, getAttackGraph());
        assemblyChange.calculateAssemblyContextToLinkingResourcePropagation();
    }
    
    @Test
    public void dontCompromiseCriticalTest() {
        runAssemblyAssemblyPropagation(getChanges());
        final var criticalEntity = getCriticalEntity();
        Assert.assertTrue(isInGraph(criticalEntity));
        assertCompromisationStatus(false, false, criticalEntity, null);
        
        final var attackPaths = getAttackGraph().findAllAttackPaths(getBlackboardWrapper(), getChanges());
        Assert.assertEquals(0, attackPaths.size());
    }
    
    @Test
    public void compromiseCriticalVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var terminal = getFirstEntityByName("Assembly_UserTerminal");
        integrateVulnerability(criticalEntity, vuln);
        
        runAssemblyAssemblyPropagation(getChanges());
        Assert.assertTrue(isInGraph(criticalEntity));
        assertCompromisationStatus(true, true, criticalEntity, vuln.getId());
        
        final var attackPaths = getAttackGraph().findAllAttackPaths(getBlackboardWrapper(), getChanges());
        final var attackPathsSet = new HashSet<>(attackPaths);
        final var content = new AttackStatusEdgeContent();
        content.addSet(new HashSet<CredentialsVulnearbilitiesSurface>(Arrays.asList(new VulnerabilitySurface(vuln))));
        final var expectedSet = addAttackLoops(Arrays.asList(new AttackPathSurface[] {
            new AttackPathSurface(
                    Arrays.asList(toEdge(content, terminal, criticalEntity)))
        }), criticalEntity, content);
        Assert.assertEquals(3, attackPaths.size());
        doDebugSysOutExpectedAndUnexpectedPaths(expectedSet, attackPathsSet);
        Assert.assertEquals(expectedSet, attackPathsSet);
    }
    
    @Test
    public void compromiseCriticalAndTerminalVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var userDb = getFirstEntityByName("Assembly_UserDB");
        final var terminal = getFirstEntityByName("Assembly_UserTerminal");
        integrateVulnerability(criticalEntity, vuln);
        integrateVulnerability(terminal, vuln);
        
        runAssemblyAssemblyPropagation(getChanges());
        Assert.assertTrue(isInGraph(criticalEntity));
        assertCompromisationStatus(true, true, criticalEntity, vuln.getId());
        
        final var attackPaths = getAttackGraph().findAllAttackPaths(getBlackboardWrapper(), getChanges());
        final var attackPathsSet = new HashSet<>(attackPaths);
        final var content = new AttackStatusEdgeContent();
        content.addSet(new HashSet<CredentialsVulnearbilitiesSurface>(Arrays.asList(new VulnerabilitySurface(vuln))));
        final var expectedSet = addAttackLoops(Arrays.asList(new AttackPathSurface[] {
            new AttackPathSurface(
                        Arrays.asList(
                                toEdge(content, userDb, terminal),
                                toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, terminal, terminal), 
                            toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, criticalEntity, terminal), 
                            toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, criticalEntity, terminal), 
                            toEdge(content, terminal, terminal), 
                            toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, userDb, terminal),
                            toEdge(content, terminal, criticalEntity))),
            new AttackPathSurface(
                    Arrays.asList(
                            toEdge(content, userDb, terminal),
                            toEdge(content, terminal, terminal), 
                            toEdge(content, terminal, criticalEntity)))
        }), criticalEntity, content);
        doDebugSysOutExpectedAndUnexpectedPaths(expectedSet, attackPathsSet);
        Assert.assertEquals(13, attackPaths.size());
        Assert.assertEquals(expectedSet, attackPathsSet);
    }
    
    @Test
    public void compromiseCriticalContainerVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var criticalContainingResource = getResource((AssemblyContext)criticalEntity);
        integrateVulnerability(criticalContainingResource, vuln);
        
        runAssemblyResourcePropagation(getChanges());
        assertCompromisationStatus(true, true, criticalContainingResource, vuln.getId());
    }
    
    @Test
    public void compromiseOtherContainerVulnerabilityTest() {
        final var cweid = this.createCWEID(0);
        final var vuln = createCWEVulnerability(cweid, true, false);
        final var criticalEntity = getCriticalEntity();
        final var resource = this.getConnectedResourceContainers(
                getResource((AssemblyContext)criticalEntity)).get(0);
        integrateVulnerability(resource, vuln);
        
        runAssemblyResourcePropagation(getChanges());
        assertCompromisationStatus(true, true, resource, vuln.getId());
    }
}
