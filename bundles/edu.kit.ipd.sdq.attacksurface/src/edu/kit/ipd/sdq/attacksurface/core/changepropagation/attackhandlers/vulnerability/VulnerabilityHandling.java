package edu.kit.ipd.sdq.attacksurface.core.changepropagation.attackhandlers.vulnerability;

import java.util.List;
import java.util.Optional;

import org.eclipse.emf.ecore.EObject;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.ConfidentialityImpact;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;

import edu.kit.ipd.sdq.attacksurface.core.AttackHandlingHelper;
import edu.kit.ipd.sdq.attacksurface.core.changepropagation.changes.HelperUpdateCredentialChange;
import edu.kit.ipd.sdq.attacksurface.graph.AttackGraph;
import edu.kit.ipd.sdq.attacksurface.graph.AttackNodeContent;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

/**
 * Represents an abstract class for handling vulnerabilities.
 * 
 * @author ugnwq
 * @author majuwa
 * @version 1.0
 * @param <T> the type of the attacked entity
 */
abstract class VulnerabilityHandling<T> {

    /**
     * Executes the vulnerability handling for the given arguments.
     * 
     * @param element - the attacked element
     * @param change - the changes
     * @param source - the attack source 
     * @param vulnerability - the vulnerability
     * @param attackerNodeInGraph - the attacker node in the attack graph
     * @param attackedNodeInGraph - the attacked node in the attack graph
     * @param attackGraph - the attack graph
     * 
     * @return the compromised entity including the compromisation information 
     * or a {@code none} value if the entity was not taken over
     */
    public Optional<T> executeVulnerabilityHandling(final EObject element, final CredentialChange change,
            final EObject source, final Vulnerability vulnerability, 
            final AttackNodeContent attackerNodeInGraph,
            final AttackNodeContent attackedNodeInGraph,
            final AttackGraph attackGraph) {
        if (vulnerability == null) {
            return Optional.empty();
        }
        if (!vulnerability.getGainedAttributes().isEmpty()) {
            final var streamCredentials = vulnerability.getGainedAttributes().stream()
                    .map(credential -> HelperUpdateCredentialChange.createContextChange(credential,
                            List.of(element, vulnerability)));
            HelperUpdateCredentialChange.updateCredentials(
                    change, streamCredentials, attackerNodeInGraph, attackedNodeInGraph, attackGraph);
        }
        if (vulnerability.isTakeOver()) {
            return this.handleTakeOver(element, source, vulnerability);

        } else if (vulnerability.getConfidentialityImpact() != ConfidentialityImpact.NONE) {
            this.handleConfidentiality(element);
        }
        return Optional.empty();
    }

    /**
     * Handles the takeover of an element
     * 
     * @param container - the element
     * @param source - the attack source
     * @param vulnerability - the vulnerability
     * 
     * @return the compromised entity including the compromisation information
     */
    protected abstract Optional<T> handleTakeOver(EObject container, EObject source, Vulnerability vulnerability);

    protected abstract void handleConfidentiality(EObject container);

}
