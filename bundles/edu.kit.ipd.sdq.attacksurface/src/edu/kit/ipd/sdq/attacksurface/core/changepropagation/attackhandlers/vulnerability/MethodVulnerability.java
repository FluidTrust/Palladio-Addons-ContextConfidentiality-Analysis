package edu.kit.ipd.sdq.attacksurface.core.changepropagation.attackhandlers.vulnerability;

import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.function.Function;

import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.CollectionHelper;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.HelperCreationCompromisedElements;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attacker.helper.VulnerabilityHelper;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.Vulnerability;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.ServiceRestriction;

import edu.kit.ipd.sdq.attacksurface.core.changepropagation.attackhandlers.MethodHandler;
import edu.kit.ipd.sdq.attacksurface.core.changepropagation.changes.CauseGetter;
import edu.kit.ipd.sdq.attacksurface.graph.AttackGraph;
import edu.kit.ipd.sdq.attacksurface.graph.CVSurface;
import edu.kit.ipd.sdq.attacksurface.graph.VulnerabilitySurface;
import edu.kit.ipd.sdq.kamp4attack.core.BlackboardWrapper;
import edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability.VulnerabilityHandlingSEFF;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

public class MethodVulnerability extends MethodHandler {

    private final AttackVector attackVector;

    public MethodVulnerability(final BlackboardWrapper modelStorage, final DataHandlerAttacker dataHandler,
            final AttackVector attackVector, final AttackGraph attackGraph) {
        super(modelStorage, dataHandler, attackGraph);
        this.attackVector = attackVector;
    }

    @Override
    protected Optional<CompromisedAssembly> attackComponent(final ServiceRestriction restriction,
            final CredentialChange change, final EObject source) {
        final var credentials = getCredentials(change);
        final var attacks = getAttacks();

        // find the original methodspecification of the model, necessary later for comparison since
        // the methodspecification contains a unique id
        final var method = CollectionHelper.findOrCreateServiceRestriction(restriction,
                getModelStorage().getVulnerabilitySpecification(), change);


        final var vulnerabilityList = VulnerabilityHelper
                .getVulnerabilities(getModelStorage().getVulnerabilitySpecification(), method);
        final var vulnerability = this.checkVulnerability(method, change, credentials, attacks, vulnerabilityList,
                this.attackVector);

        final var seffHandling = new VulnerabilityHandlingSEFF(method.getAssemblycontext(), getDataHandler());
        final var tmpReturnValue = seffHandling.executeVulnerabilityHandling(method, change, source, vulnerability);
        if (tmpReturnValue.isPresent()) {
            return tmpReturnValue;
        }
        else if (vulnerability != null) {// only service compromised but not the component
            final var sourceList = createSource(source, credentials);

            final var compromised = HelperCreationCompromisedElements.createCompromisedService(method, sourceList);
            var serviceRestrictions = CollectionHelper.filterExistingService(List.of(compromised), change);
            if (!serviceRestrictions.isEmpty()) {
                //TODO adapt and remove > change.getCompromisedservice().addAll(serviceRestrictions);
                change.setChanged(true);
            }
        }

        return Optional.empty();

    }

    @Override
    protected Set<String> getCauses(EList<EObject> causingElements) {
        return CauseGetter.getCauses(causingElements, Vulnerability.class);
    }

    @Override
    protected Function<String, CVSurface> getSurfaceMapper() {
        return VulnerabilitySurface::new;
    }

}
