package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attacker.helper.VulnerabilityHelper;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.PCMElement;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.VulnerabilitySystemIntegration;
import org.palladiosimulator.pcm.confidentiality.context.system.pcm.structure.ServiceRestriction;

import edu.kit.ipd.sdq.kamp4attack.core.BlackboardWrapper;
import edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.MethodHandler;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

public class MethodVulnerability extends MethodHandler {

    private final AttackVector attackVector;

    public MethodVulnerability(final BlackboardWrapper modelStorage, final DataHandlerAttacker dataHandler,
            final AttackVector attackVector) {
        super(modelStorage, dataHandler);
        this.attackVector = attackVector;
    }

    @Override
    protected Optional<CompromisedAssembly> attackComponent(final ServiceRestriction restriction,
            final CredentialChange change, final EObject source) {
        final var credentials = this.getCredentials(change);
        final var attacks = this.getAttacks();

        // find the original methodspecification of the model, necessary later for comparison since
        // the methodspecification contains a unique id
        final var listMethodSpecification = this.getModelStorage().getVulnerabilitySpecification().getVulnerabilities()
                .stream().filter(VulnerabilitySystemIntegration.class::isInstance)
                .map(VulnerabilitySystemIntegration.class::cast)
                .filter(e -> e.getPcmelement().getMethodspecification() != null)
                .map(VulnerabilitySystemIntegration::getPcmelement).map(PCMElement::getMethodspecification)
                .filter(ServiceRestriction.class::isInstance).map(ServiceRestriction.class::cast)
                .filter(e -> EcoreUtil.equals(e.getService(), restriction.getService())
                        && EcoreUtil.equals(e.getAssemblycontext(), restriction.getAssemblycontext()))
                .collect(Collectors.toList());

        for (final var method : listMethodSpecification) {
            final var vulnerabilityList = VulnerabilityHelper
                    .getVulnerabilities(this.getModelStorage().getVulnerabilitySpecification(), method);
            final var vulnerability = this.checkVulnerability(method, change, credentials, attacks, vulnerabilityList,
                    this.attackVector);

            final var seffHandling = new VulnerabilityHandlingSEFF(method.getAssemblycontext(), this.getDataHandler());
            final var tmpReturnValue = seffHandling.executeVulnerabilityHandling(method, change, source, vulnerability);
            if (tmpReturnValue.isPresent()) {
                return tmpReturnValue;
            }
        }
        return Optional.empty();

    }

}
