package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attacker.helper.VulnerabilityHelper;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.SystemIntegration;
import org.palladiosimulator.pcm.confidentiality.context.helper.PolicyHelper;
import org.palladiosimulator.pcm.confidentiality.context.specification.assembly.ProvidedRestriction;
import org.palladiosimulator.pcm.core.composition.AssemblyConnector;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.repository.OperationProvidedRole;
import org.palladiosimulator.pcm.resourceenvironment.LinkingResource;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;

import edu.kit.ipd.sdq.kamp4attack.core.BlackboardWrapper;
import edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.AssemblyContextHandler;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

public class AssemblyContextVulnerability extends AssemblyContextHandler {

    private final AttackVector attackVector;

    public AssemblyContextVulnerability(final BlackboardWrapper modelStorage, final DataHandlerAttacker dataHandler,
            final AttackVector attackVector) {
        super(modelStorage, dataHandler);
        this.attackVector = attackVector;
    }

    @Override
    protected Optional<CompromisedAssembly> attackComponent(final AssemblyContext component,
            final CredentialChange change, final EObject source) {
        var credentials = getCredentials(change);
        final var attacks = getAttacks();
        var vulnerabilityList = VulnerabilityHelper
                .getVulnerabilities(getModelStorage().getVulnerabilitySpecification(), component);
        var policies = PolicyHelper.getPolicy(getModelStorage().getSpecification(), component);
        credentials = addCredentialsLocal(this.attackVector, credentials, policies);
        var vulnerability = VulnerabilityHelper.checkAttack(credentials, policies, vulnerabilityList, attacks,
                this.attackVector);
        final var handling = new VulnerabilityHandlingAssemblyContext(getDataHandler());
        var assembly = handling.executeVulnerabilityHandling(component, change, source, vulnerability);
        if (assembly.isEmpty()) {
            List<OperationProvidedRole> connectors;
            if (source instanceof AssemblyContext) {
                // TODO Flow-Control
                connectors = getModelStorage().getAssembly().getConnectors__ComposedStructure().stream()
                        .filter(AssemblyConnector.class::isInstance).map(AssemblyConnector.class::cast)
                        .filter(e -> (EcoreUtil.equals(source, e.getRequiringAssemblyContext_AssemblyConnector())
                                && EcoreUtil.equals(component, e.getProvidingAssemblyContext_AssemblyConnector())))
                        .map(AssemblyConnector::getProvidedRole_AssemblyConnector) // possible
                                                                                   // extraction of
                                                                                   // connector
                        .collect(Collectors.toUnmodifiableList());
            } else if (source instanceof LinkingResource) {
                final var connectorList = getConnectors(component);
                connectors = new ArrayList<>();
                for (final var connector : connectorList) {
                    final var resource = getResource(component, connector);
                    if (((LinkingResource) source).getConnectedResourceContainers_LinkingResource().stream()
                            .anyMatch(e -> EcoreUtil.equals(resource, e))) {
                        connectors.add(connector.getProvidedRole_AssemblyConnector());
                    }
                }
            } else if (source instanceof ResourceContainer) {
                final var connectorList = getConnectors(component);
                connectors = new ArrayList<>();
                for (final var connector : connectorList) {
                    final var resource = getResource(component, connector);
                    final var list = getLinkingResource(resource);
                    for (final var linking : list) {
                        final var booleanDestination = linking.getConnectedResourceContainers_LinkingResource().stream()
                                .anyMatch(e -> EcoreUtil.equals(resource, e));
                        final var booleanSource = linking.getConnectedResourceContainers_LinkingResource().stream()
                                .anyMatch(e -> EcoreUtil.equals(component, e));
                        if (booleanDestination && booleanSource) {
                            connectors.add(connector.getProvidedRole_AssemblyConnector());
                            break;
                        }
                    }
                }
            } else {
                connectors = new ArrayList<>();
            }

            final var listMethodSpecification = getModelStorage().getVulnerabilitySpecification().getVulnerabilities()
                    .stream().filter(e -> e.getMethodspecification() != null)
                    .map(SystemIntegration::getMethodspecification).filter(ProvidedRestriction.class::isInstance)
                    .map(ProvidedRestriction.class::cast)
                    .filter(e -> connectors.stream()
                            .anyMatch(f -> EcoreUtil.equals(e.getProvidedrole(), f)
                                    && EcoreUtil.equals(e.getAssemblycontext(), component)))
                    .collect(Collectors.toList());

            for (final var method : listMethodSpecification) {
                policies = PolicyHelper.getPolicy(getModelStorage().getSpecification(), method);
                vulnerabilityList = VulnerabilityHelper
                        .getVulnerabilities(getModelStorage().getVulnerabilitySpecification(), method);
                vulnerability = VulnerabilityHelper.checkAttack(credentials, policies, vulnerabilityList, attacks,
                        this.attackVector);
                final var seffHandling = new VulnerabilityHandlingSEFF(component, getDataHandler());
                final var tmpReturnValue = seffHandling.executeVulnerabilityHandling(method, change, source,
                        vulnerability);
                if (tmpReturnValue.isPresent()) {
                    assembly = tmpReturnValue;
                }
            }

        }
        return assembly;
    }

    private List<AssemblyConnector> getConnectors(final AssemblyContext component) {
        final var connectorList = getModelStorage().getAssembly().getConnectors__ComposedStructure().stream()
                .filter(AssemblyConnector.class::isInstance).map(AssemblyConnector.class::cast)
                .filter(e -> (EcoreUtil.equals(component, e.getProvidingAssemblyContext_AssemblyConnector())
                        || EcoreUtil.equals(component, e.getRequiringAssemblyContext_AssemblyConnector())))
                .collect(Collectors.toList());
        return connectorList;
    }

    private ResourceContainer getResource(final AssemblyContext component, final AssemblyConnector connector) {
        AssemblyContext assemblyContext = null;
        if (EcoreUtil.equals(connector.getProvidingAssemblyContext_AssemblyConnector(), component)) {
            assemblyContext = connector.getRequiringAssemblyContext_AssemblyConnector();
        } else {
            assemblyContext = connector.getProvidingAssemblyContext_AssemblyConnector();
        }
        final var resource = getResourceContainer(assemblyContext);
        return resource;
    }

    private ResourceContainer getResourceContainer(final AssemblyContext component) {
        final var allocationOPT = getModelStorage().getAllocation().getAllocationContexts_Allocation().stream()
                .filter(allocation -> EcoreUtil.equals(allocation.getAssemblyContext_AllocationContext(), component))
                .findAny();
        if (allocationOPT.isEmpty()) {
            throw new IllegalStateException("No Allocation for assemblycontext " + component + " found");
        }
        final var resource = allocationOPT.get().getResourceContainer_AllocationContext();
        return resource;
    }

    private List<LinkingResource> getLinkingResource(final ResourceContainer container) {
        final var resourceEnvironment = getModelStorage().getResourceEnvironment();
        return resourceEnvironment.getLinkingResources__ResourceEnvironment().stream()
                .filter(e -> e.getConnectedResourceContainers_LinkingResource().stream()
                        .anyMatch(f -> EcoreUtil.equals(f, container)))
                .collect(Collectors.toList());
    }

}
