package edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.vulnerability;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.palladiosimulator.pcm.confidentiality.attacker.analysis.common.data.DataHandlerAttacker;
import org.palladiosimulator.pcm.confidentiality.attacker.helper.VulnerabilityHelper;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.attackSpecification.AttackVector;
import org.palladiosimulator.pcm.confidentiality.attackerSpecification.pcmIntegration.SystemIntegration;
import org.palladiosimulator.pcm.confidentiality.context.helper.PolicyHelper;
import org.palladiosimulator.pcm.confidentiality.context.specification.assembly.MethodSpecification;
import org.palladiosimulator.pcm.core.composition.AssemblyConnector;
import org.palladiosimulator.pcm.core.composition.AssemblyContext;
import org.palladiosimulator.pcm.core.composition.Connector;
import org.palladiosimulator.pcm.resourceenvironment.LinkingResource;
import org.palladiosimulator.pcm.resourceenvironment.ResourceContainer;

import edu.kit.ipd.sdq.kamp4attack.core.BlackboardWrapper;
import edu.kit.ipd.sdq.kamp4attack.core.changepropagation.attackhandlers.AssemblyContextHandler;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CompromisedAssembly;
import edu.kit.ipd.sdq.kamp4attack.model.modificationmarks.KAMP4attackModificationmarks.CredentialChange;

public class AssemblyContextVulnerability extends AssemblyContextHandler {

    private AttackVector attackVector;

    public AssemblyContextVulnerability(BlackboardWrapper modelStorage, DataHandlerAttacker dataHandler,
            AttackVector attackVector) {
        super(modelStorage, dataHandler);
        this.attackVector = attackVector;
    }

    @Override
    protected Optional<CompromisedAssembly> attackComponent(AssemblyContext component, CredentialChange change,
            EObject source) {
        var credentials = this.getCredentials(change);
        var attacks = getAttacks();
        var vulnerabilityList = VulnerabilityHelper
                .getVulnerabilities(this.getModelStorage().getVulnerabilitySpecification(), component);
        var policies = PolicyHelper.getPolicy(this.getModelStorage().getSpecification(), component);
        credentials = this.addCredentialsLocal(attackVector, credentials, policies);
        var vulnerability = VulnerabilityHelper.checkAttack(credentials, policies, vulnerabilityList, attacks,
                attackVector);
        var handling = new VulnerabilityHandlingAssemblyContext(getDataHandler());
        var assembly = handling.executeVulnerabilityHandling(component, change, source, vulnerability);
        if (assembly.isEmpty()) {
            List<Connector> connectors;
            if (source instanceof AssemblyContext) {
                connectors = this.getModelStorage().getAssembly().getConnectors__ComposedStructure().stream()
                        .filter(AssemblyConnector.class::isInstance).map(AssemblyConnector.class::cast).filter(e -> {
                            return (EcoreUtil.equals(source, e.getProvidingAssemblyContext_AssemblyConnector())
                                    && EcoreUtil.equals(component, e.getRequiringAssemblyContext_AssemblyConnector()))
                                    || (EcoreUtil.equals(source, e.getRequiringAssemblyContext_AssemblyConnector())
                                            && EcoreUtil.equals(component,
                                                    e.getProvidingAssemblyContext_AssemblyConnector()));
                        }).collect(Collectors.toUnmodifiableList());
            } else if (source instanceof LinkingResource) {
                var connectorList = getConnectors(component);
                connectors = new ArrayList<>();
                for (var connector : connectorList) {
                    var resource = getResource(component, connector);
                    if (((LinkingResource) source).getConnectedResourceContainers_LinkingResource().stream()
                            .anyMatch(e -> EcoreUtil.equals(resource, e)))
                        connectors.add(connector);
                }
            } else if (source instanceof ResourceContainer) {
                var connectorList = getConnectors(component);
                connectors = new ArrayList<>();
                for (var connector : connectorList) {
                    var resource = getResource(component, connector);
                    var list = getLinkingResource(resource);
                    for (var linking : list) {
                        var booleanDestination = linking.getConnectedResourceContainers_LinkingResource().stream()
                                .anyMatch(e -> EcoreUtil.equals(resource, e));
                        var booleanSource = linking.getConnectedResourceContainers_LinkingResource().stream()
                                .anyMatch(e -> EcoreUtil.equals(component, e));
                        if (booleanDestination && booleanSource) {
                            connectors.add(connector);
                            break;
                        }
                    }
                }
            } else {
                connectors = new ArrayList<>();
            }

            var listMethodSpecification = this.getModelStorage().getVulnerabilitySpecification().getVulnerabilities()
                    .stream().filter(e -> e.getMethodspecification() != null).map(SystemIntegration::getMethodspecification)
                    .filter(e -> connectors.stream().anyMatch(f -> EcoreUtil.equals(e.getConnector(), f)))
                    .collect(Collectors.toList());

            for (var method : listMethodSpecification) {
                policies = PolicyHelper.getPolicy(this.getModelStorage().getSpecification(), method);
                vulnerabilityList = VulnerabilityHelper.getVulnerabilities(this.getModelStorage().getVulnerabilitySpecification(), method);
                vulnerability = VulnerabilityHelper.checkAttack(credentials, policies, vulnerabilityList, attacks,
                        attackVector);
                var seffHandling = new VulnerabilityHandlingSEFF(component, getDataHandler());
                var tmpReturnValue = seffHandling.executeVulnerabilityHandling(method, change, source,
                        vulnerability);
                if (tmpReturnValue.isPresent())
                    assembly = tmpReturnValue;
            }

        }
        return assembly;
    }

    private List<AssemblyConnector> getConnectors(AssemblyContext component) {
        var connectorList = this.getModelStorage().getAssembly().getConnectors__ComposedStructure().stream()
                .filter(AssemblyConnector.class::isInstance).map(AssemblyConnector.class::cast).filter(e -> {
                    return (EcoreUtil.equals(component, e.getProvidingAssemblyContext_AssemblyConnector())
                            || EcoreUtil.equals(component, e.getRequiringAssemblyContext_AssemblyConnector()));
                }).collect(Collectors.toList());
        return connectorList;
    }

    private ResourceContainer getResource(AssemblyContext component, AssemblyConnector connector) {
        AssemblyContext assemblyContext = null;
        if (EcoreUtil.equals(connector.getProvidingAssemblyContext_AssemblyConnector(), component))
            assemblyContext = connector.getRequiringAssemblyContext_AssemblyConnector();
        else
            assemblyContext = connector.getProvidingAssemblyContext_AssemblyConnector();
        var resource = getResourceContainer(assemblyContext);
        return resource;
    }

    private ResourceContainer getResourceContainer(final AssemblyContext component) {
        final var allocationOPT = this.getModelStorage().getAllocation().getAllocationContexts_Allocation().stream()
                .filter(allocation -> EcoreUtil.equals(allocation.getAssemblyContext_AllocationContext(), component))
                .findAny();
        if (allocationOPT.isEmpty()) {
            throw new IllegalStateException("No Allocation for assemblycontext " + component + " found");
        }
        final var resource = allocationOPT.get().getResourceContainer_AllocationContext();
        return resource;
    }

    private List<LinkingResource> getLinkingResource(final ResourceContainer container) {
        final var resourceEnvironment = this.getModelStorage().getResourceEnvironment();
        return resourceEnvironment.getLinkingResources__ResourceEnvironment().stream()
                .filter(e -> e.getConnectedResourceContainers_LinkingResource().stream()
                        .anyMatch(f -> EcoreUtil.equals(f, container)))
                .collect(Collectors.toList());
    }

}
